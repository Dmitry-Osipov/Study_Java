package Algorithms;

public class lesson1 {
    public static void main(String[] args) {
        // Задача 1: определить допустимые делители для числа
        int number = 12;
        System.out.println(findAvailableDivider(number));

        // Задача 2: поиск простых чисел на определённом отрезке от 0 до n
        int maxNumberInList = 6;
        System.out.println(findSimpleNumbers(maxNumberInList));

        // Задача 3: поиск вероятности выпадения определенной суммы на игральных костях
        int desiredSum = 12;
        System.out.println(findSumDice(desiredSum));

        // Задача 4: нахождение n-ого числа Фибоначчи
        int countNumber = 5;
        System.out.println(fibNumbers(countNumber));
    }

    // Определение допустимых делителей для числа
    public static String findAvailableDivider(int number) {
        StringBuilder result = new StringBuilder();
        for (int divider = 1; divider <= number; divider++) {
            if (number % divider == 0) {
                result.append(divider).append(" ");
            }
        }
        return result.toString();
    }

    /*
    Данный алгоритм является линейным. Линейная зависимость характеризуется симметричным ростом количества шагов
    относительно увеличения объёма входных данных. Для числа 12 будет 12 действий по перебору элементов, для 25 - 25.
     */

    // Поиск простых чисел на отрезке от 0 до n
    public static String findSimpleNumbers(int maxNumberInList) {
        StringBuilder result = new StringBuilder();
        int counter = 0;
        for (int i = 1; i <= maxNumberInList; i++) {
            boolean simple = true;
            for (int j = 2; j < i; j++) {
                counter++;
                if (i % j == 0) {
                    simple = false;
                    break;
                }
            }
            if (simple) {
                result.append(i).append(" ");
            }
        }
        System.out.println("Counter: " + counter);
        return result.toString();
    }

    /*
      С ростом числа количество входящих операций растёт гораздо быстрее. Данная зависимость называется квадратичной.
      Она характеризуется резким ростом сложности относительно роста размера входных данных.

      Для описания сложности алгоритма существует общепринятая нотация - O(f(n)) или просто O(n), где n - это размер
      входных данных.
      Например, алгоритм перебора массива циклом for имеет сложность O(n). С ростом n на x, количество шагов алгоритма
      тоже вырастает на x.
      А использование вложенного цикла for уже будет иметь сложность O(n^2), например, при n = 3 цикл сделает
      9 итераций, а при n = 4 - уже 16 и т.д.
      Нотация большого О не даёт точного количества действий. Как минимум, мы не учитываем преобразование из двоичной
      системы в десятичную, не учитываем выделение временной памяти для заполнения массива, не учитываем операцию
      сравнения чисел и т.п. Чётко это высказывание можно понять, добавив счётчик операций для вложенного цикла.
      Для числа отрезка от 1 до 4 потребовалось 3 действия для нахождения всех простых чисел. При этом, увеличивая длину
      отрезка на 1, мы получим на счётчике цифру 6. Для 6 счётчик увеличился до 10. Однако данный счётчик чётко
      показывает резкое увеличение количества операций с постепенным увеличением входных данных.
      Оценка сложности алгоритма - это достаточно абстрактная вещь, которая не призвана, чтобы делать точный расчёт
      сложности. Однако она может помочь при работе с высоко нагруженными системами.

      Помимо двух перечисленных выше алгоритмов существует ещё более крутой график (а на самом деле один из наименее
      релевантных с точки зрения использования в программировании) - это график экспоненциальной зависимости. Пример:
      задача по поиску шанса выпадения определённой суммы на игральных костях (для трёх шестигранных кубиков).
     */

    // Поиск вероятности выпадения определенной суммы на игральных костях
    public static double findSumDice(int desiredSum) {
        int count = 0;
        int successResult = 0;
        for (int i = 1; i <= 6; i++) {
            for (int j = 1; j <= 6; j++) {
                for (int k = 1; k <= 6; k++) {
                    if (i + j + k == desiredSum) {
                        successResult++;
                    }
                    count++;
                }
            }
        }
        return (double) successResult / count;
    }

    /*
      Когда мы не знаем глубину вложенных циклов для наших расчётов, то така зависимость называется экспоненциальной.
      Технически у неё низкая производительность засчёт того, что увеличение числа n приводит к колоссальному росту
      количества операций. Для примера экспоненциальной сложности можно рассмотреть рекурсивный расчёт числа Фибоначчи.
      Сложность поиска m числа Фибоначчи можно представить как O(n^(2^(m-1))).
     */


    // Находим n-ое число Фибоначчи
    public static int fibNumbers(int count) {
        if (count == 1 || count == 2) {
            return 1;
        }

        return fibNumbers(count - 1) + fibNumbers(count - 2);
    }


    /*
    Правила объединения сложности.
    Вызов нескольких методов на каждом шаге: O(2n) == O(n).
    Обход половины размерности массива: O(n/2) == O(n).
    Вызов нескольких методов вне цикла: O(2+n) == O(n).
    Цифровые множители и цифровые слагаемые сокращаются. Это связано с тем, что математическая погрешность допускается в
    пределах 5%. Также это связано с тем, что базовая характеристика кривизны от цифровых показателей не изменится - мы
    всё равно будем получать линейный, квадратичный и т.п. рост.

    Всё сложнее обстоит, когда алгоритмы вложены друг в друга.
    method1 имеет сложность O(n^3). method2 имеет сложность O(n^2). Если method1 будет вызываться из method2, то их
    сложности перемножаются: O(n^3) * O(n^2) = O(n^5). А если методы будут вызываться последовательно, то их сложности
    складываются, т.е. берётся максимальная из них: O(n^3) + O(n^2) = O(n^3).
     */


    // Метод 1
    public static int method1(int n) {
        int count = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                for (int k = 0; k < n; k++) {
                    count++;
                }
            }
        }
        return count;
    }

    // Метод 2
    public static int method2(int n) {
        int count = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                count++;
            }
        }
        return count;
    }
}

/*
Наиболее частые сложности алгоритмов:
O(1) - константная. Не зависит от объёма данных. Например, поиск по хэш-таблице.
O(log n) - логарифмическая. Увеличение размера почти не сказывается на количестве итераций. Например, бинарный поиск,
поиск по сбалансированному дереву.
O(n) - линейная. Увеличение сложности эквивалентно увеличению размера. Например, поиск по неотсортированному массиву.
O(n * log n) - увеличение размера заметно сказывается на сложности. Например, быстрая сортировка.
O(n^2) - квадратичная. Увеличение размера очень сильно сказывается на сложности. Например, пузырьковая сортировка.
O(2^n) - экспоненциальная. С увеличением размера на 1 сложность возрастает вдвое.
 */